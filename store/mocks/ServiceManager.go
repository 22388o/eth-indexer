// Code generated by mockery v1.0.0
package mocks

import common "github.com/ethereum/go-ethereum/common"
import mock "github.com/stretchr/testify/mock"
import model "github.com/maichain/eth-indexer/model"

// ServiceManager is an autogenerated mock type for the ServiceManager type
type ServiceManager struct {
	mock.Mock
}

// FindAccount provides a mock function with given fields: address, blockNr
func (_m *ServiceManager) FindAccount(address common.Address, blockNr ...int64) (*model.Account, error) {
	_va := make([]interface{}, len(blockNr))
	for _i := range blockNr {
		_va[_i] = blockNr[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, address)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *model.Account
	if rf, ok := ret.Get(0).(func(common.Address, ...int64) *model.Account); ok {
		r0 = rf(address, blockNr...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.Account)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(common.Address, ...int64) error); ok {
		r1 = rf(address, blockNr...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FindBlockByHash provides a mock function with given fields: hash
func (_m *ServiceManager) FindBlockByHash(hash []byte) (*model.Header, error) {
	ret := _m.Called(hash)

	var r0 *model.Header
	if rf, ok := ret.Get(0).(func([]byte) *model.Header); ok {
		r0 = rf(hash)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.Header)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func([]byte) error); ok {
		r1 = rf(hash)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FindBlockByNumber provides a mock function with given fields: blockNumber
func (_m *ServiceManager) FindBlockByNumber(blockNumber int64) (*model.Header, error) {
	ret := _m.Called(blockNumber)

	var r0 *model.Header
	if rf, ok := ret.Get(0).(func(int64) *model.Header); ok {
		r0 = rf(blockNumber)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.Header)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(int64) error); ok {
		r1 = rf(blockNumber)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FindContract provides a mock function with given fields: address, blockNr
func (_m *ServiceManager) FindContract(address common.Address, blockNr ...int64) (*model.Contract, error) {
	_va := make([]interface{}, len(blockNr))
	for _i := range blockNr {
		_va[_i] = blockNr[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, address)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *model.Contract
	if rf, ok := ret.Get(0).(func(common.Address, ...int64) *model.Contract); ok {
		r0 = rf(address, blockNr...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.Contract)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(common.Address, ...int64) error); ok {
		r1 = rf(address, blockNr...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FindContractCode provides a mock function with given fields: address
func (_m *ServiceManager) FindContractCode(address common.Address) (*model.ContractCode, error) {
	ret := _m.Called(address)

	var r0 *model.ContractCode
	if rf, ok := ret.Get(0).(func(common.Address) *model.ContractCode); ok {
		r0 = rf(address)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.ContractCode)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(common.Address) error); ok {
		r1 = rf(address)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FindLatestBlock provides a mock function with given fields:
func (_m *ServiceManager) FindLatestBlock() (*model.Header, error) {
	ret := _m.Called()

	var r0 *model.Header
	if rf, ok := ret.Get(0).(func() *model.Header); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.Header)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FindStateBlock provides a mock function with given fields: blockNr
func (_m *ServiceManager) FindStateBlock(blockNr int64) (*model.StateBlock, error) {
	ret := _m.Called(blockNr)

	var r0 *model.StateBlock
	if rf, ok := ret.Get(0).(func(int64) *model.StateBlock); ok {
		r0 = rf(blockNr)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.StateBlock)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(int64) error); ok {
		r1 = rf(blockNr)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FindTransaction provides a mock function with given fields: hash
func (_m *ServiceManager) FindTransaction(hash []byte) (*model.Transaction, error) {
	ret := _m.Called(hash)

	var r0 *model.Transaction
	if rf, ok := ret.Get(0).(func([]byte) *model.Transaction); ok {
		r0 = rf(hash)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.Transaction)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func([]byte) error); ok {
		r1 = rf(hash)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FindTransactionsByBlockHash provides a mock function with given fields: blockHash
func (_m *ServiceManager) FindTransactionsByBlockHash(blockHash []byte) ([]*model.Transaction, error) {
	ret := _m.Called(blockHash)

	var r0 []*model.Transaction
	if rf, ok := ret.Get(0).(func([]byte) []*model.Transaction); ok {
		r0 = rf(blockHash)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*model.Transaction)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func([]byte) error); ok {
		r1 = rf(blockHash)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LastStateBlock provides a mock function with given fields:
func (_m *ServiceManager) LastStateBlock() (*model.StateBlock, error) {
	ret := _m.Called()

	var r0 *model.StateBlock
	if rf, ok := ret.Get(0).(func() *model.StateBlock); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.StateBlock)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}
